var decorateMethodAfter = require('utils/decorateMethodAfter');

function manageSceneRayCollisions(scene, rayEvents) {
	var objectsWithGetColliders = [];
	var colliders = [];
	var draggingColliders = [];
	var lastFocusedObject = null;

	rayEvents.addOnMove(_onMoveOrDrag);
	rayEvents.addOnDrag(_onMoveOrDrag);
	rayEvents.addOnStart(_onStart);
	rayEvents.addOnEnd(_onEnd);
	rayEvents.addOnSelect(_onSelect);

	function addColliders(item) {
		if(item.getColliders && objectsWithGetColliders.indexOf(item) === -1) {
			objectsWithGetColliders.push(item);
			var colliders = item.getColliders();
			if(colliders instanceof Array) {
				_addColliders(colliders);
			} else if(colliders) {
				_addCollider(colliders);
			} else {
				throw new Error('No collider!');
			}
		}
	}

	decorateMethodAfter(scene, 'add', addColliders);

	function removeColliders(item) {
		var index = objectsWithGetColliders.indexOf(item);
		if(index !== -1) {
			var item = objectsWithGetColliders.splice(index, 1)[0];
			var colliders = item.getColliders();
			if(colliders instanceof Array) {
				_removeColliders(colliders);
			} else if(colliders) {
				_removeCollider(colliders);
			} else {
				throw new Error('No collider!');
			}
		}
	}
	decorateMethodAfter(scene, 'remove', removeColliders);

	function onEnterFrameUpdateRay(dt) {
		var focusedObject = _getObjectUnderRay();
		if(focusedObject !== lastFocusedObject) {
			if(lastFocusedObject) {
				lastFocusedObject.onOut();
			}
			if(focusedObject) {
				focusedObject.onOver();
			}
			lastFocusedObject = focusedObject;
		}
	}
	decorateMethodAfter(scene, 'onEnterFrame', onEnterFrameUpdateRay);


	function _addCollider(collider) {
		if(!collider) {
			throw new Error('collider must be a Mesh.');
		}
		colliders.push(collider);
	}

	function _removeCollider(collider) {
		const index = colliders.indexOf(collider);
		
		if (index !== -1) {
			colliders.splice(index, 1);
		}
	}

	function _addColliders(colliders) {
		colliders.forEach(_addCollider);
	}

	function _removeColliders(colliders) {
		colliders.forEach(_removeCollider);
	}

	function _getObjectUnderRay() {
		if(!scene.rayLauncher) return;
		var hit = scene.rayLauncher.getCollision(colliders);
		var focusedObject = hit ? hit.object : null;
		if(focusedObject && focusedObject.collisionOwner) {
			focusedObject = focusedObject.collisionOwner;
		}
		return focusedObject;
	}

	function _onMoveOrDrag(pos) {
		if(!scene.rayLauncher) return;
		scene.rayLauncher.updateRayCoord(pos);
		if(draggingObject) {
			var hit = scene.rayLauncher.getCollision(draggingColliders);
			var pos3d = hit ? hit.point : null;
			draggingObject.onDrag(pos3d);
		}
	}

	function _onSelect(pos) {
		if(!scene.rayLauncher) return;
		_onMoveOrDrag(pos);
		var hit = scene.rayLauncher.getCollision(colliders);
		var focusedObject = hit ? hit.object : null;
		if(focusedObject && focusedObject.collisionOwner) {
			focusedObject = focusedObject.collisionOwner;
		}
		if(focusedObject && focusedObject.onSelect) {
			focusedObject.onSelect(hit.point);
		}
	}

	var draggingObject;
	function _onStart(pos) {
		if(!scene.rayLauncher) return;
		scene.rayLauncher.updateRayCoord(pos);
		var hit = scene.rayLauncher.getCollision(colliders);
		var hitObject = hit ? hit.object : null;
		if(hitObject && hitObject.onStart) {
			draggingObject = hitObject;
			draggingColliders = [hitObject];
			draggingObject.onStart(hit.point);
		}
	}

	function _onEnd(pos) {
		if(!scene.rayLauncher) return;
		scene.rayLauncher.updateRayCoord(pos);
		var hit = _getObjectUnderRay();
		if(hit && hit.onEnd) {
			hit.onEnd();
		}
		if(draggingObject) {
			draggingObject.onEnd();
			draggingObject = null;
			draggingColliders.length = 0;
		}
	}


}

module.exports = manageSceneRayCollisions;
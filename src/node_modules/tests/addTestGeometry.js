var THREE = require('three');
var defaults = require('lodash.defaults');
var rando = require('utils/createDeterministicRandomRange')(2);

var __defaultParams = {
	totalTestObjects: 16,
	totalBoxes: 0,
	merge: true,
	padding: 0.05
};

function addTestGeometry(params) {
	params = defaults(params, __defaultParams);
	if(!params.scene) throw new Error('Missing a threejs scene.');

	var scene = params.scene;
	var geometries = [];
	var cols = 4;
	var rows = 4;
	var total = cols * rows;
	var padding = params.padding;
	var paddedScale = 1 - (2 * params.padding);
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.SphereGeometry(0.5, 16, 8);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = (vert.x * paddedScale + col + padding) / cols;
				vert.y = (vert.y * paddedScale + row + padding) / rows;
			});
		});
		geometries.push(geometry);
	}
	for (var i = 0; i < params.totalTestObjects; i++) {
		var geometry = geometries[i % total];
		var testSphere = new THREE.Mesh(geometry, params.material);
		// testSphere.position.set(
		// 	rando() * 10 - 5,
		// 	rando() * 1 + 1,
		// 	rando() * 10 - 5
		// );
		var angle = i / params.totalTestObjects * Math.PI * 2;
		testSphere.position.set(
			Math.sin(angle) * 3,
			1.5,
			Math.cos(angle) * 3
		);
		scene.add(testSphere);
		testSphere.castShadow = true;
		testSphere.receiveShadow = true;
	}

	var tileGeometries = [];
	for (var i = 0; i < 4; i++) {
		var col = ~~(i / rows);
		var row = i % rows;
		var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = (vert.x * paddedScale + col + padding) / cols;
				vert.y = (vert.y * paddedScale + row + padding) / rows;
			});
		});
		tileGeometries.push(geometry);
	}
	var boxGeometries = [];
	for (var i = 0; i < total; i++) {
		var row = ~~(i / cols);
		var col = i % cols;
		var geometry = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
		geometry.faceVertexUvs[0].forEach(function(vertArray) {
			vertArray.forEach(function(vert) {
				// if(vert.touchedUvs) debugger;
				// vert.touchedUvs = true;
				vert.x = (vert.x * paddedScale + col + padding) / cols;
				vert.y = (vert.y * paddedScale + row + padding) / rows;
			});
		});
		boxGeometries.push(geometry);
	}

	var cols = 40;
	var rows = 40;
	var half = cols * 0.5;
	var total = cols * rows;
	var floorMergedGeometry = new THREE.Geometry();
	for (var i = total-1; i >= 0; i--) {
		var row = i % cols;
		var col = ~~(i / cols);
		var floorTile = new THREE.Mesh(
			tileGeometries[~~(rando() * tileGeometries.length)],
			params.material
		);
		floorTile.rotation.x += Math.PI * -0.5;
		scene.add(floorTile);
		floorTile.position.set(row - half + 0.5, 0.05, col - half + 0.5);
		floorTile.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(floorTile);
			scene.remove(floorTile);
		}
	}
	
	var total = params.totalBoxes;
	for (var i = total-1; i >= 0; i--) {
		var box = new THREE.Mesh(
			boxGeometries[~~(rando() * boxGeometries.length)],
			params.material
		);
		scene.add(box);
		while(box.position.length() < 3) {
			box.position.set(
				rando() * 20 - 10,
				rando() * 20 - 10,
				rando() * 20 - 10
			);
		}

		box.castShadow = true;
		box.receiveShadow = true;
		if(params.merge) {
			floorMergedGeometry.mergeMesh(box);
			scene.remove(box);
		}
	}
	
	// this sorts the geometry from closest to furthest to 0, 0, 0. This ensures that renders from near 0, 0, 0 are the fastest possible.
	// This optimization only really works for opaque objects viewed from a fixed position.
	if(params.merge) {
		var floorMerged = new THREE.Mesh(floorMergedGeometry, params.material);
		floorMerged.castShadow = true;
		floorMerged.receiveShadow = true;
		scene.add(floorMerged);
		var verts = floorMergedGeometry.vertices;
		var faces = floorMergedGeometry.faces;
		var uvs = floorMergedGeometry.faceVertexUvs[0];
		faces.forEach(function(face){
			var avg = new THREE.Vector3();
			avg.add(verts[face.a]);
			avg.add(verts[face.b]);
			avg.add(verts[face.c]);
			face.dist = avg.length();
		});
		for (var i = uvs.length - 1; i >= 0; i--) {
			uvs[i].dist = faces[i].dist;
		}
		faces.sort(function(a, b) {
			return a.dist - b.dist;
		});
		uvs.sort(function(a, b) {
			return a.dist - b.dist;
		});
	}
	
}

module.exports = addTestGeometry;
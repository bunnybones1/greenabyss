var defaults = require('lodash.defaults');
var THREE = require('three');
var eases = require('eases');

var Material = require('materials/TemporalColorStripMaterial');
const seedRandom = require('utils/seedRandom');

require('three/examples/js/loaders/ColladaLoader2');

var __defaultParams = {
	radius: 80,
	height: 40,
	mapFrameHeight: 5, 
	mapFrames: 48, 
	mapFrameTop: 0,
	mapFrameBottom: 8,
	mapTotalHeight: 256, 
	total: 5,
	sizeMin: 0.005,
	sizeMax: 0.01,
	layer: 0,
	fogNear: 0,
	fogFar: 1000,
	speed: 0.25
};

function SpriteClouds(params) {
	params = defaults(params, __defaultParams);

	THREE.Object3D.call(this);

	var material = new Material({
		mapTexture: params.mapTexture,
		mapFrameHeight: params.mapFrameHeight, 
		mapFrames: params.mapFrames, 
		mapTotalHeight: params.mapTotalHeight,
		blendMode: 'normal',
		colorFog: params.colorFog,
		fogNear: params.fogNear,
		fogFar: params.fogFar,
		// wireframe: true
	});

	this.clouds = [];
	this.material = material;
	this.jumpDistance = 0.71 * params.radius;
	this.jumpThresh = 0.85 * params.radius;
	var loader = new THREE.ColladaLoader2();
	loader.load('assets/meshes/clouds.dae', _onLoadColladaBuildMeshes.bind(this, params));
}

function _onLoadColladaBuildMeshes (params, colladaData) {
	var rand = seedRandom(4);
	var geometryBaseNames = [
		'small',
		'medium',
		'large',
		'xlarge'
	];
	var geometries = [];
	geometryBaseNames.forEach(function(baseName) {
		var geometry = colladaData.library.geometries['cloud-'+baseName+'-lib'].build.null.geometry;
		var positionArray = geometry.attributes.normal.array;
		var normalArray = geometry.attributes.normal.array;
		var uvArray = geometry.attributes.uv.array;
		var total = geometry.attributes.normal.count;
		var halfPixelOffset = 0.5 / params.mapTotalHeight;
		var mapFrameHeight = params.mapFrameBottom - params.mapFrameTop;
		var adjustedFrameHeight = (mapFrameHeight - 1) / params.mapTotalHeight;
		var topOffset = halfPixelOffset * (1 + 2 * params.mapFrameTop);
		for (var i = 0; i < total; i++) {
			var i3 = i * 3;
			var i2 = i * 2;
			var x = normalArray[i3] * 0.5 + 0.5;
			var y = normalArray[i3+1] * 0.5 + 0.5;
			y *= adjustedFrameHeight;
			y += topOffset;
			uvArray[i2] = x;
			uvArray[i2+1] = y;
		}
		geometries.push(geometry);
	});

	for (var i = 0; i < params.total; i++) {
		var index = Math.floor(eases.sineIn(i/params.total) * geometries.length);
		console.log('geom', index);
		var cloud = new THREE.Mesh(
			geometries[index], 
			this.material
		);

		var pos = cloud.position;
		pos.x = 99;
		while(pos.length() > 1) {
			pos.x = rand(-1, 1);
			pos.z = rand(-1, 1);
		}
		var scale = rand(params.sizeMin, params.sizeMax);
		cloud.scale.multiplyScalar(scale);
		cloud.speed = (14 - index) * params.speed;
		pos.multiplyScalar(this.jumpDistance);
		pos.y = params.height + scale * 0.5;
		this.add(cloud);
		cloud.layers.set(params.layer);
		this.clouds.push(cloud);
	}
	this.rand = rand;
}

SpriteClouds.prototype = Object.create(THREE.Object3D.prototype);

SpriteClouds.prototype.onEnterFrame = function(dt) {
	for (var i = 0; i < this.clouds.length; i++) {
		var cloud = this.clouds[i];
		cloud.position.x += dt * cloud.speed;
		if(cloud.position.length() > this.jumpThresh) {
			var angle = this.rand(0.6, 1.4) * Math.PI;
			cloud.position.x = Math.cos(angle) * this.jumpDistance;
			cloud.position.z = Math.sin(angle) * this.jumpDistance;
			// cloud.position.x *= -1;
		}
	}
}

module.exports = SpriteClouds;
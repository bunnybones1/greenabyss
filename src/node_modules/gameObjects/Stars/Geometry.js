const THREE = require('three');
var defaults = require('lodash.defaults');
var pseudorandomSpacedPointsOnSphere = require('pseudorandom-spaced-points-on-sphere');
var eases = require('eases');

const seedRandom = require('utils/seedRandom');


var __defaultParams = {
	total: 10000,
	radius: 80,
	sizeMin: 0.2,
	sizeMax: 1,
};

function StarsGeometry(params) {
	params = defaults(params, __defaultParams);

	THREE.BufferGeometry.call( this );

	this.type = 'StarsGeometry';

	var vertex = new THREE.Vector3();

	// buffers

	var vertices = new Array(params.total * 3);
	var sizes = new Array(params.total);


	var rand = seedRandom(10);
	var galaxyNeighbourhoodScale = new THREE.Vector3(10000, 10000, 5000);
	function randomize() {
		vertex.set(
			rand(-1, 1), 
			rand(-1, 1),
			eases.sineIn(rand()) * (rand() > 0.5 ? 1 : -1)
		);
	}


	var radius = params.radius;
	var sizeMin = params.sizeMin;
	var sizeRange = params.sizeMax - sizeMin;
	var total = params.total;

	vertex.set(-1, -1, 1);
	vertex.multiply(galaxyNeighbourhoodScale);
	var maxDistance = vertex.length();

	for (var i = 0; i < total; i++) {
		randomize();
		if(i < 10) {
			console.log(vertex);
		}
		while (vertex.length() > 1) {
			randomize();
		}
		vertex.multiply(galaxyNeighbourhoodScale);
		var distance = vertex.length();
		vertex.normalize();
		vertex.multiplyScalar(radius);
		vertex.toArray(vertices, i*3);
		sizes[i] = (sizeMin + sizeRange * Math.pow((1 - (distance / maxDistance)), 2)) * (sizeMin + (eases.expoIn(rand(0, 1)) * sizeRange));
	}

	// build geometry

	this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ) );
}

StarsGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

module.exports = StarsGeometry;
var defaults = require('lodash.defaults');
var THREE = require('three');

var Combinatorics = require('js-combinatorics');
var tweener = require('tweeners/game-raf');

/*

	Notes on Inverse Kinematics.

	This sheep has 4 legs. In order to animate these legs, the following strategy was used:
	Don't try to solve each leg's 3 segments as an IK chain.
	Instead, just cache the poses that each leg can stretch to and sort the poses by overall length.
	For instance a tucked leg can be 20cm from hip to foot, but an outstreched leg can be 80cm.
	When solving the leg, think of each leg as a telescope. Just point the leg at the foot target and measure the length to the target.
	Then just lookup the bone poses for the leg in the cache for that length.
	It should look good enough.
	Some rotation axis orders needed to be switched from XYZ to ZYX for better rotations.

*/

require('three/examples/js/loaders/ColladaLoader');

var __defaultParams = {
	showSkin: true,
	showHelpers: false,
	speed: 2
};
	
var __material;
function __getMaterial() {
	if(!__material) {
		__material = new THREE.MeshStandardMaterial({
			map: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-diffuse.png'),
			// normalMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-normal.png'),
			// emissive: 0xffffff,
			roughness: 1.0,
			metalness: 0.6,
			skinning: true,
			// emissiveMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-emissive.png'),
			subSurfaceAbsorbColorMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-subSurfaceAbsorbColor.png'),
			metalnessMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-metalness.png'),
			roughnessMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-roughness.png'),
			// wireframe: true
		});
	}
	return __material;
}

function GoldHornedSheep(params) {
	params = defaults(params, __defaultParams);

	THREE.Object3D.call(this);

	this.material = __getMaterial();
	var loader = new THREE.ColladaLoader();
	this.boneMaterial = params.boneMaterial;
	this.nextPosition = new THREE.Vector3(); //to get proper lookAt for sheep
	this.speed = params.speed;
	this.originalSpeed = this.speed;
	this.followTarget = params.followTarget;
	this.showSkin = params.showSkin;
	this.showHelpers = params.showHelpers;
	loader.load('assets/meshes/gold-horned-sheep.dae', _onLoadColladaBuildMeshes.bind(this, params));
}

function _onLoadColladaBuildMeshes (params, colladaData) {
	// var geometry = colladaData.library.geometries['sheep-skin-lib'].build['gold horned sheep'].geometry;
	var originalSheepMesh = colladaData.skins[0];
	// var geometry = colladaData.skins[0].geometry;
	// var sheep = new THREE.SkinnedMesh(
	// 	geometry, 
	// 	this.material
	// );
	var sheep = originalSheepMesh;
	//world units in 3dsmax were set to centimeters and it's too much work to convert everything back to meters
	sheep.scale.multiplyScalar(0.01);
	sheep.material = this.material;

	if(this.showHelpers) {
		var skeletonHelper = new THREE.SkeletonHelper(sheep);
		this.parent.add(skeletonHelper);
		this.skeletonHelper = skeletonHelper;
	}

	var _this = this;

	var skeleton = colladaData.scene.children[2];


	function bindToMasterBones(master, slave) {
		if(!master || !slave) return;
		if(master.name === '') debugger;
		slave.name = master.name + '_slave';
		slave.master = master;
		console.log(master.name, master.rotation, slave.rotation);
		var masters = master.children.filter(function notAMesh(child) {
			return !(child.children[0] instanceof THREE.Mesh);
		});
		masters.forEach(function matchSlavesToMastersByPosition(subMaster) {
			slave.children.forEach(function prepareDistanceCheck(subSlave) {
				subSlave.distanceCheck = subSlave.position.clone().sub(subMaster.position).length();
			});
			slave.children.sort(function sortByDistanceCheck(a, b) {
				return a.distanceCheck - b.distanceCheck;
			});
			if(slave.children.length >= 2 && slave.children[0].distanceCheck === slave.children[1].distanceCheck) {
				console.warn('ambiguous');
			}
			bindToMasterBones(subMaster, slave.children[0]);
		});
	}
	bindToMasterBones(skeleton, sheep.children[0]);

	skeleton = sheep.children[0];

	//modelled a tiny sheep.. whoops
	this.scale.multiplyScalar(3);
	//disreagard sheep skin for now, it's all about the bones.
	sheep.visible = this.showSkin;
	//treat "this" as the sheep's center of gravity for ease of movement, position skeleton accordingly
	skeleton.position.z -= 25;
	// skeleton.position.y = 0.06;
	skeleton.rotation.x += -Math.PI * 0.5;
	//cache original positions for animation
	skeleton.position.originalX = skeleton.position.x;
	skeleton.position.originalY = skeleton.position.y;
	skeleton.position.originalZ = skeleton.position.z;

	var boneMaterial = this.boneMaterial;
	var bones = [];
	//traverse the entire skeleton and prepare the ik bones and visual bones
	function processBones(target) {
		console.log('test', target.name);
		if(target.name.indexOf('bone_') !== -1) {
			bones.push(target);
			//cache original rotations for animation
			target.rotation.originalX = target.rotation.x;
			target.rotation.originalY = target.rotation.y;
			target.rotation.originalZ = target.rotation.z;
		} 
		target.children.forEach(processBones);
		if(target.material) {
			target.castShadow = true;
			target.receiveShadow = true;

			target.material = boneMaterial;
			boneMaterial.morphUvsToMaterialSwatch(target.geometry, 'bone');
		}
	}
	processBones(skeleton);

	//quick utils to grab bones
	function filterByName(name, exclude, bone) {
		return bone.name.indexOf(name) !== -1 && bone.name.indexOf(exclude) === -1;
	}

	function getBone(nameChunk, exclude, nth) {
		return bones.filter(filterByName.bind(null, nameChunk, exclude))[nth || 0];	
	}

	//special bones for animation
	var spineBones = bones.filter(filterByName.bind(null, 'spine', 'special'));

	this.skull = getBone('skull');
	this.jaw = getBone('jaw');

	var rearLeg = [
		getBone('femur', 'mirrored'),
		getBone('fibula', 'mirrored'),
		getBone('tarsals', 'mirrored')
	];

	var frontLeg = [
		getBone('humerous', 'mirrored'),
		getBone('radius', 'mirrored'),
		getBone('carpals', 'mirrored')
	];

	var rearLeg2 = [
		getBone('femur_mirrored'),
		getBone('fibula_mirrored'),
		getBone('tarsals_mirrored')
	];
	var frontLeg2 = [
		getBone('humerous_mirrored'),
		getBone('radius_mirrored'),
		getBone('carpals_mirrored')
	];

	var temp = colladaData.scene.children[2];
	rearLeg[2].endEffectorOffset = temp.getObjectByName('bone_tarsals_end_mirrored_').position;
	rearLeg2[2].endEffectorOffset = temp.getObjectByName('bone_tarsals_end').position;
	frontLeg[2].endEffectorOffset = temp.getObjectByName('bone_carpals_end_mirrored_').position;
	frontLeg2[2].endEffectorOffset = temp.getObjectByName('bone_carpals_end').position;


	//some helpers that live in world space (children of scene)
	function createAxisHelper() {
		var helper = new THREE.AxisHelper(0.5);
		helper.visible = _this.showHelpers;
		_this.parent.add(helper);
		return helper;
	}

	this.worldHip = createAxisHelper();
	this.worldFoot = createAxisHelper();

	this.worldShoulder = createAxisHelper();
	this.worldHand = createAxisHelper();

	this.worldHip2 = createAxisHelper();
	this.worldFoot2 = createAxisHelper();

	this.worldShoulder2 = createAxisHelper();
	this.worldHand2 = createAxisHelper();

	function lerpRotZ(mix) {
		this.z = this.minZ + mix * this.rangeZ;
	}
	function refreshMatrices(target) {
		target.updateMatrix();
		target.updateMatrixWorld();
	}
	function alternatingBoneLimits(bone, i) {
		var m = (i%2) * 2 - 1;
		var rot = bone.rotation;
		rot.maxZ = bone.rotation.z;
		rot.minZ = Math.PI * 0.85 * m;
		rot.rangeZ = rot.maxZ - rot.minZ;
	}

	rearLeg[0].rotation.minZ = rearLeg[0].rotation.z + 0.5; 
	rearLeg[0].rotation.maxZ = rearLeg[0].rotation.z;
	rearLeg[0].rotation.rangeZ = rearLeg[0].rotation.maxZ - rearLeg[0].rotation.minZ; 
	rearLeg.slice(1, 3).forEach(alternatingBoneLimits);

	frontLeg.forEach(alternatingBoneLimits);
	frontLeg[0].rotation.minZ = frontLeg[0].rotation.z - 0.4; 
	frontLeg[0].rotation.maxZ = frontLeg[0].rotation.z;
	frontLeg[0].rotation.rangeZ = frontLeg[0].rotation.maxZ - frontLeg[0].rotation.minZ; 

	rearLeg2[0].rotation.minZ = rearLeg2[0].rotation.z + 0.5; 
	rearLeg2[0].rotation.maxZ = rearLeg2[0].rotation.z;
	rearLeg2[0].rotation.rangeZ = rearLeg2[0].rotation.maxZ - rearLeg2[0].rotation.minZ; 
	rearLeg2.slice(1, 3).forEach(alternatingBoneLimits);

	frontLeg2.forEach(alternatingBoneLimits);
	frontLeg2[0].rotation.minZ = frontLeg2[0].rotation.z - 0.4; 
	frontLeg2[0].rotation.maxZ = frontLeg2[0].rotation.z;
	frontLeg2[0].rotation.rangeZ = frontLeg2[0].rotation.maxZ - frontLeg2[0].rotation.minZ; 

	[
		rearLeg[0],
		frontLeg[0],
		rearLeg2[0],
		frontLeg2[0]
	].forEach(function rejigBoneForRig(bone) {
		bone.rotation.order = "ZYX";
		bone.up.set(0, 0, 1);
		bone.updateMatrix();
	});


	//instead of doing proper IK for the legs, we can find a range of realistic bent leg poses, and build a cache
	//each leg pose has a resulting length from hip to foot.
	//Later on we can just find the pose closest to the real length needed to connect the leg to the target length	
	var rearLegPoseCache = [];
	var frontLegPoseCache = [];
	var rearLeg2PoseCache = [];
	var frontLeg2PoseCache = [];
	var steps = 100;
	var temp = new THREE.Vector3();
	for (var i = steps; i >= 0; i--) {
		var ratio = i / steps;
		lerpRotZ.call(rearLeg[0].rotation, ratio);
		rearLeg[0].updateMatrix();
		lerpRotZ.call(rearLeg[1].rotation, ratio);
		rearLeg[1].updateMatrix();
		lerpRotZ.call(rearLeg[2].rotation, ratio);
		rearLeg[2].updateMatrix();
		//get this temp point to be at the foot tip position but in the local space of the hip
		temp.copy(rearLeg[2].endEffectorOffset);
		// temp.applyMatrix4(rearLeg[3].matrix);
		temp.applyMatrix4(rearLeg[2].matrix);
		temp.applyMatrix4(rearLeg[1].matrix);
		rearLegPoseCache.push({
			length: temp.length() * 0.03,
			angle0: rearLeg[0].rotation.z,
			angle1: rearLeg[1].rotation.z,
			angle2: rearLeg[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});

		lerpRotZ.call(frontLeg[0].rotation, ratio);
		frontLeg[0].updateMatrix();
		lerpRotZ.call(frontLeg[1].rotation, ratio);
		frontLeg[1].updateMatrix();
		lerpRotZ.call(frontLeg[2].rotation, ratio);
		frontLeg[2].updateMatrix();
		//get this temp point to be at the hand tip position but in the local space of the shoulder
		temp.copy(frontLeg[2].endEffectorOffset);
		// temp.applyMatrix4(frontLeg[3].matrix);
		temp.applyMatrix4(frontLeg[2].matrix);
		temp.applyMatrix4(frontLeg[1].matrix);
		frontLegPoseCache.push({
			length: temp.length() * 0.03,
			angle0: frontLeg[0].rotation.z,
			angle1: frontLeg[1].rotation.z,
			angle2: frontLeg[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});
		lerpRotZ.call(rearLeg2[0].rotation, ratio);
		rearLeg2[0].updateMatrix();
		lerpRotZ.call(rearLeg2[1].rotation, ratio);
		rearLeg2[1].updateMatrix();
		lerpRotZ.call(rearLeg2[2].rotation, ratio);
		rearLeg2[2].updateMatrix();
		//get this temp point to be at the foot tip position but in the local space of the hip
		temp.copy(rearLeg2[2].endEffectorOffset);
		// temp.applyMatrix4(rearLeg2[3].matrix);
		temp.applyMatrix4(rearLeg2[2].matrix);
		temp.applyMatrix4(rearLeg2[1].matrix);
		rearLeg2PoseCache.push({
			length: temp.length() * 0.03,
			angle0: rearLeg2[0].rotation.z,
			angle1: rearLeg2[1].rotation.z,
			angle2: rearLeg2[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});

		lerpRotZ.call(frontLeg2[0].rotation, ratio);
		frontLeg2[0].updateMatrix();
		lerpRotZ.call(frontLeg2[1].rotation, ratio);
		frontLeg2[1].updateMatrix();
		lerpRotZ.call(frontLeg2[2].rotation, ratio);
		frontLeg2[2].updateMatrix();
		//get this temp point to be at the hand tip position but in the local space of the shoulder
		temp.copy(frontLeg2[2].endEffectorOffset);
		// temp.applyMatrix4(frontLeg2[3].matrix);
		temp.applyMatrix4(frontLeg2[2].matrix);
		temp.applyMatrix4(frontLeg2[1].matrix);
		frontLeg2PoseCache.push({
			length: temp.length() * 0.03,
			angle0: frontLeg2[0].rotation.z,
			angle1: frontLeg2[1].rotation.z,
			angle2: frontLeg2[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});
	}
	this.rearLegPoseCache = rearLegPoseCache;
	this.frontLegPoseCache = frontLegPoseCache;
	this.rearLeg2PoseCache = rearLeg2PoseCache;
	this.frontLeg2PoseCache = frontLeg2PoseCache;
	//fix scale of exported skin
	// skeleton.scale.multiplyScalar(0.01);
	sheep.rotation.x = Math.PI * -0.5;
	this.add(sheep);
	sheep.castShadow = true;
	sheep.receiveShadow = true;

	//exports
	this.spineBones = spineBones;
	this.skeleton = skeleton;
	this.rearLeg = rearLeg;
	this.frontLeg = frontLeg;
	this.rearLeg2 = rearLeg2;
	this.frontLeg2 = frontLeg2;

	this.sheep = sheep;

	var helperMaterial = new THREE.MeshBasicMaterial({
		wireframe: true,
		depthTest: false,
		transparent: true
	});
	var bodyHelper = new THREE.Mesh(
		new THREE.SphereGeometry(0.17),
		helperMaterial
	);
	this.add(bodyHelper);
	bodyHelper.visible = this.showHelpers;

	var now = performance.now();
	var nowish = now * 0.01;
	var nowishSlow = nowish * 0.5;
	this.nextPosition.set(
		Math.cos(nowish * 0.05) * 4,
		Math.cos(nowish+Math.PI * -1.5) * 0.1 + 0.7,
		Math.sin(nowish * 0.05) * 4
	);
	this.position.copy(this.nextPosition);

	function createFootTarget(guide, delay) {
		var footTarget = new THREE.Mesh(
			new THREE.SphereGeometry(0.05),
			helperMaterial
		);
		_this.parent.add(footTarget);

		footTarget.position.copy(_this.position);
		footTarget.position.y = 0;
		footTarget.position._virtualY = 0;
		Object.defineProperty(
			footTarget.position, 
			'virtualY', 
			{
				get: function() {
					return this._virtualY;
				},
				set: function(val) {
					this.y = Math.sin(val * Math.PI) * 0.45;
					this._virtualY = val;
				}
			}
		);
		footTarget.lastPosition = footTarget.position.clone();
		_this.stepFoot(footTarget, guide, delay / _this.speed);

		footTarget.visible = _this.showHelpers;
		return footTarget;
	}

	this.footTargetLeft = createFootTarget(this.rearLeg2[0]);
	this.footTargetRight = createFootTarget(this.rearLeg[0], 100);

	this.handTargetLeft = createFootTarget(this.frontLeg2[0], 200);
	this.handTargetRight = createFootTarget(this.frontLeg[0], 300);
}

GoldHornedSheep.prototype = Object.create(THREE.Object3D.prototype);

var __tempVec = new THREE.Vector3();
var __pos = new THREE.Vector3();
var __scale = new THREE.Vector3();
var __rot = new THREE.Euler();
var __quat = new THREE.Quaternion();
var __mat = new THREE.Matrix4();

GoldHornedSheep.prototype.sleepFoot = function(footTarget, guide, delay) {
	if(isNaN(guide.matrixWorld.elements[0])) {
		tweener.to(
			footTarget.position,
			0.3 / this.speed,
			{
				onComplete: this.sleepFoot.bind(this, footTarget, guide),
				delay: delay || 0
			}
		);
		return;
	}
	__pos.set(0, 0, 0);
	__pos.applyMatrix4(guide.matrixWorld);
	var distance = Math.pow(__pos.x - footTarget.position.x, 2) + Math.pow(__pos.z - footTarget.position.z, 2);
	var next = this.idle ? this.standFoot : this.stepFoot;
	if(distance < 0.05) next = this.sleepFoot
	tweener.to(
		footTarget.position,
		0.3 / this.speed,
		{
			onComplete: next.bind(this, footTarget, guide),
			delay: delay || 0
		}
	)
}

GoldHornedSheep.prototype.stepFoot = function(footTarget, guide, delay) {
	if(isNaN(guide.matrixWorld.elements[0])) {
		tweener.to(
			footTarget.position,
			0.3 / this.speed,
			{
				onComplete: this.sleepFoot.bind(this, footTarget, guide, delay),
				delay: delay || 0
			}
		);
		return;
	}
	__pos.set(0, 0, 0);
	__pos.applyMatrix4(guide.matrixWorld);
	footTarget.position.virtualY = 0;
	tweener.to(
		footTarget.position,
		0.3 / this.speed,
		{
			// x: __pos.x,
			// y: __pos.y,
			// z: __pos.z,
			x: __pos.x + (__pos.x - footTarget.lastPosition.x) * 1,
			// y: __pos.y,
			z: __pos.z + (__pos.z - footTarget.lastPosition.z) * 1,
			virtualY: 1,
			delay: delay || 0,
			onComplete: this.sleepFoot.bind(this, footTarget, guide)
		}
	)
	footTarget.lastPosition.copy(__pos);
}

GoldHornedSheep.prototype.standFoot = function(footTarget, guide, delay) {
	if(isNaN(guide.matrixWorld.elements[0])) {
		tweener.to(
			footTarget.position,
			0.3 / this.speed,
			{
				onComplete: this.sleepFoot.bind(this, footTarget, guide, delay),
				delay: delay || 0
			}
		);
		return;
	}
	__pos.set(0, 0, 0);
	__pos.applyMatrix4(guide.matrixWorld);
	footTarget.position.virtualY = 0;
	tweener.to(
		footTarget.position,
		0.3 / this.speed,
		{
			x: __pos.x,
			// y: __pos.y,
			z: __pos.z,
			virtualY: 1,
			delay: delay || 0,
			onComplete: this.sleepFoot.bind(this, footTarget, guide)
		}
	)
	footTarget.lastPosition.copy(__pos);
}

function __updateHelperWorldMatrix(leg, helper) {
	leg.updateMatrix();
	leg.parent.updateMatrix();
	leg.updateMatrixWorld();
	leg.parent.updateMatrixWorld();
	helper.position.set(0, 0, 0).applyMatrix4(leg.matrixWorld);
	helper.updateMatrix();
	helper.updateMatrixWorld();
}

GoldHornedSheep.prototype.onEnterFrame = function(dt) {
	var now = performance.now();
	var nowish = now * 0.01 * this.speed;
	var nowishSlow = nowish * 0.5;
	if(this.skeletonHelper) {
		this.skeletonHelper.update();
	}
	this.nextPosition.copy(this.followTarget.position);
	this.nextPosition.y = 0.7;
	this.nextPosition.sub(this.position);
	var length = this.nextPosition.length();
	if(length > 2) {
		this.nextPosition.normalize().multiplyScalar(0.15);
		this.speed = this.originalSpeed * 2;
	} else if(length > 0.05) {
		this.nextPosition.normalize().multiplyScalar(0.05);
		this.speed = this.originalSpeed;
	}
	this.idle = length < 0.01;
	this.nextPosition.add(this.position);
	if(length > 0.02) {
		var temp = this.rotation.y;
		this.lookAt(this.nextPosition);
		var temp2 = this.rotation.y;
		if(!isNaN(temp) && !isNaN(temp2)) {
			if((temp2 - temp) > Math.PI) temp2 -= Math.PI * 2;
			if((temp2 - temp) < Math.PI) temp2 += Math.PI * 2;
			var delta = temp - temp2;
			var delta2 = delta * 0.2;
			this.rotation.y = temp - delta2;
		}
	}
	this.position.copy(this.nextPosition);
	var breathingSpeed = this.idle ? 0.25 : 1;
	if(this.skeleton) {
		this.skeleton.rotation.y = Math.sin(nowish * Math.PI * 2 * 0.6 * 0.2 * breathingSpeed + 1.57) * 0.1 - Math.PI * 0.5;
		this.skeleton.rotation.x = Math.PI * 0.25;
		// this.skeleton.rotation.z = Math.cos(nowish * Math.PI * 2 * 0.6 * 0.5 + 1.57) * 0.1;
		this.spineBones.forEach(function(bone, i) {
			bone.rotation.z = bone.rotation.originalZ - Math.sin((nowish + i) * breathingSpeed) * 0.1 * breathingSpeed;
			// bone.rotation.x = bone.rotation.originalY - Math.cos(nowish + i) * 0.1;
		});
		this.skull.rotation.x = Math.sin(nowishSlow) * 0.2 * breathingSpeed;
		this.jaw.rotation.z = Math.sin(nowish - 4) * 0.3 * breathingSpeed - 0.3;
		// var index = ~~nowish % rearLegPoseCache.length;

		__updateHelperWorldMatrix(this.rearLeg[0], this.worldHip);
		__updateHelperWorldMatrix(this.frontLeg[0], this.worldShoulder);
		__updateHelperWorldMatrix(this.rearLeg2[0], this.worldHip2);
		__updateHelperWorldMatrix(this.frontLeg2[0], this.worldShoulder2);

		this.worldFoot.position.copy(this.footTargetRight.position);
		this.worldHand.position.copy(this.handTargetRight.position);
		this.worldFoot2.position.copy(this.footTargetLeft.position);
		this.worldHand2.position.copy(this.handTargetLeft.position);

		var length = 1;
		function prepTempDeltas(result) {
			result.tempDelta = Math.abs(length - result.length);
		}

		function sortByClosestDistance(a, b) {
			return a.tempDelta - b.tempDelta;
		}

		function solveLeg(startBoneHelper, endBoneHelper, poseCache, legArr) {
			//find the length from the shoulder/hip to the target
			//helpers in world space
			__tempVec.copy(startBoneHelper.position).sub(endBoneHelper.position);
			length = __tempVec.length();
			//sort cache by length delta
			poseCache.forEach(prepTempDeltas);
			poseCache.sort(sortByClosestDistance);

			//point whole leg pose at the target
			__pos.copy(endBoneHelper.position);
			__mat.getInverse(legArr[0].parent.matrixWorld);
			__pos.applyMatrix4(__mat);
			legArr[0].lookAt(__pos);
			legArr[0].rotation.x -= Math.PI * 0.5;

			//set leg to correct pose from cache
			var bestPose = poseCache[0];
			legArr[0].rotation.z -= Math.PI * 0.5 + bestPose.majorAngle;
			legArr[1].rotation.z = bestPose.angle1;
			legArr[2].rotation.z = bestPose.angle2;

		}
		solveLeg(this.worldHip, this.worldFoot, this.rearLegPoseCache, this.rearLeg);
		solveLeg(this.worldHip2, this.worldFoot2, this.rearLeg2PoseCache, this.rearLeg2);
		solveLeg(this.worldShoulder, this.worldHand, this.frontLegPoseCache, this.frontLeg);
		solveLeg(this.worldShoulder2, this.worldHand2, this.frontLeg2PoseCache, this.frontLeg2);
	}

}

module.exports = GoldHornedSheep;
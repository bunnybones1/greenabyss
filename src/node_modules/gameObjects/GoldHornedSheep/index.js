var defaults = require('lodash.defaults');
var THREE = require('three');

var tweener = require('tweeners/game-raf');

require('three/examples/js/loaders/ColladaLoader2');

var __defaultParams = {
	showSkin: false,
	showHelpers: true
};
	
var __material;
function __getMaterial() {
	if(!__material) {
		__material = new THREE.MeshStandardMaterial({
			map: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-diffuse.png'),
			// normalMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-normal.png'),
			// emissive: 0xffffff,
			roughness: 1.0,
			metalness: 0.6,
			// emissiveMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-emissive.png'),
			subSurfaceAbsorbColorMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-subSurfaceAbsorbColor.png'),
			metalnessMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-metalness.png'),
			roughnessMap: THREE.ImageUtils.loadTexture('assets/textures/gold-horned-sheep-roughness.png'),
			// wireframe: true
		});
	}
	return __material;
}

function GoldHornedSheep(params) {
	params = defaults(params, __defaultParams);

	THREE.Object3D.call(this);

	this.material = __getMaterial();
	var loader = new THREE.ColladaLoader();
	this.boneMaterial = params.boneMaterial;
	this.nextPosition = new THREE.Vector3(); //to get proper lookAt for sheep
	this.speed = 1;
	this.showSkin = params.showSkin;
	this.showHelpers = params.showHelpers;
	loader.load('assets/meshes/gold-horned-sheep.dae', _onLoadColladaBuildMeshes.bind(this, params));
}

function _onLoadColladaBuildMeshes (params, colladaData) {
	var geometry = colladaData.library.geometries['sheep-skin-lib'].build['gold horned sheep'].geometry;
	var sheep = new THREE.Mesh(
		geometry, 
		this.material
	);

	var _this = this;

	var skeleton = colladaData.scene.children[1];
	//modelled a tiny sheep.. whoops
	this.scale.multiplyScalar(3);
	//disreagard sheep skin for now, it's all about the bones.
	sheep.visible = this.showSkin;
	//treat "this" as the sheep's center of gravity for ease of movement, position skeleton accordingly
	skeleton.position.z = -0.25;
	skeleton.position.y = 0.06;
	//cache original positions for animation
	skeleton.position.originalX = skeleton.position.x;
	skeleton.position.originalY = skeleton.position.y;
	skeleton.position.originalZ = skeleton.position.z;

	this.add(skeleton);
	var boneMaterial = this.boneMaterial;
	var bones = [];
	//traverse the entire skeleton and prepare the ik bones and visual bones
	function processBones(target) {
		if(target.name.indexOf('bone ') !== -1) {
			bones.push(target);
			//cache original rotations for animation
			target.rotation.originalX = target.rotation.x;
			target.rotation.originalY = target.rotation.y;
			target.rotation.originalZ = target.rotation.z;
		} 
		target.children.forEach(processBones);
		if(target.name.indexOf('bone_') !== -1) {
			if(target.material) {
				target.castShadow = true;
				target.receiveShadow = true;

				target.material = boneMaterial;
				boneMaterial.morphUvsToMaterialSwatch(target.geometry, 'bone');
			}
		}
	}
	processBones(skeleton);

	//quick utils to grab bones
	function filterByName(name, bone) {
		return bone.name.indexOf(name) !== -1;
	}

	function getBone(nameChunk, nth) {
		return bones.filter(filterByName.bind(null, nameChunk))[nth || 0];	
	}

	//special bones for animation
	var spineBones = bones.filter(filterByName.bind(null, 'spine'));

	this.skull = getBone('skull');
	this.jaw = getBone('jaw');

	var rearLeg = [
		getBone('femur'),
		getBone('fibula'),
		getBone('tarsals'),
		getBone('tarsals end')
	];

	var frontLeg = [
		getBone('humerous'),
		getBone('radius'),
		getBone('carpals'),
		getBone('carpals end')
	];

	var rearLeg2 = [
		getBone('femur(mirrored'),
		getBone('fibula(mirrored'),
		getBone('tarsals(mirrored'),
		getBone('tarsals end(mirrored')
	];
	var frontLeg2 = [
		getBone('humerous(mirrored'),
		getBone('radius(mirrored'),
		getBone('carpals(mirrored'),
		getBone('carpals end(mirrored')
	];

	//some helpers that live in world space (children of scene)
	function createAxisHelper() {
		var helper = new THREE.AxisHelper(0.5);
		helper.visible = _this.showHelpers;
		_this.parent.add(helper);
		return helper;
	}

	this.worldHip = createAxisHelper();
	this.worldFoot = createAxisHelper();

	this.worldShoulder = createAxisHelper();
	this.worldHand = createAxisHelper();

	this.worldHip2 = createAxisHelper();
	this.worldFoot2 = createAxisHelper();

	this.worldShoulder2 = createAxisHelper();
	this.worldHand2 = createAxisHelper();

	function lerpRotZ(mix) {
		this.z = this.minZ + mix * this.rangeZ;
	}
	function refreshMatrices(target) {
		target.updateMatrix();
		target.updateMatrixWorld();
	}
	function alternatingBoneLimits(bone, i) {
		var m = (i%2) * 2 - 1;
		var rot = bone.rotation;
		rot.maxZ = bone.rotation.z;
		rot.minZ = Math.PI * 0.85 * m;
		rot.rangeZ = rot.maxZ - rot.minZ;
	}

	rearLeg[0].rotation.minZ = rearLeg[0].rotation.z + 0.5; 
	rearLeg[0].rotation.maxZ = rearLeg[0].rotation.z;
	rearLeg[0].rotation.rangeZ = rearLeg[0].rotation.maxZ - rearLeg[0].rotation.minZ; 
	rearLeg.slice(1, 3).forEach(alternatingBoneLimits);

	frontLeg.forEach(alternatingBoneLimits);
	frontLeg[0].rotation.minZ = frontLeg[0].rotation.z - 0.4; 
	frontLeg[0].rotation.maxZ = frontLeg[0].rotation.z;
	frontLeg[0].rotation.rangeZ = frontLeg[0].rotation.maxZ - frontLeg[0].rotation.minZ; 

	[
		rearLeg[0],
		frontLeg[0],
		rearLeg2[0],
		frontLeg2[0]
	].forEach(function rejigBoneForRig(bone) {
		bone.rotation.order = "ZYX";
		bone.up.set(0, 0, 1);
		bone.updateMatrix();
	});

	//we need up-to-date matrices for some of the following calculations
	rearLeg[3].updateMatrix();
	frontLeg[3].updateMatrix();
	rearLeg2[3].updateMatrix();
	frontLeg2[3].updateMatrix();

	//instead of doing proper IK for the legs, we can find a range of realistic bent leg poses, and build a cache
	//each leg pose has a resulting length from hip to foot.
	//Later on we can just find the pose closest to the real length needed to connect the leg to the target length	
	var rearLegPoseCache = [];
	var frontLegPoseCache = [];
	var steps = 100;
	var temp = new THREE.Vector3();
	for (var i = steps; i >= 0; i--) {
		var ratio = i / steps;
		lerpRotZ.call(rearLeg[0].rotation, ratio);
		rearLeg[0].updateMatrix();
		lerpRotZ.call(rearLeg[1].rotation, ratio);
		rearLeg[1].updateMatrix();
		lerpRotZ.call(rearLeg[2].rotation, ratio);
		rearLeg[2].updateMatrix();
		//get this temp point to be at the foot tip position but in the local space of the hip
		temp.set(0, 0, 0);
		temp.applyMatrix4(rearLeg[3].matrix);
		temp.applyMatrix4(rearLeg[2].matrix);
		temp.applyMatrix4(rearLeg[1].matrix);
		rearLegPoseCache.push({
			length: temp.length() * 0.03,
			angle0: rearLeg[0].rotation.z,
			angle1: rearLeg[1].rotation.z,
			angle2: rearLeg[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});

		lerpRotZ.call(frontLeg[0].rotation, ratio);
		frontLeg[0].updateMatrix();
		lerpRotZ.call(frontLeg[1].rotation, ratio);
		frontLeg[1].updateMatrix();
		lerpRotZ.call(frontLeg[2].rotation, ratio);
		frontLeg[2].updateMatrix();
		//get this temp point to be at the hand tip position but in the local space of the shoulder
		temp.set(0, 0, 0);
		temp.applyMatrix4(frontLeg[3].matrix);
		temp.applyMatrix4(frontLeg[2].matrix);
		temp.applyMatrix4(frontLeg[1].matrix);
		frontLegPoseCache.push({
			length: temp.length() * 0.03,
			angle0: frontLeg[0].rotation.z,
			angle1: frontLeg[1].rotation.z,
			angle2: frontLeg[2].rotation.z,
			majorAngle: Math.atan2(temp.y, temp.x)
		});
	}
	this.rearLegPoseCache = rearLegPoseCache;
	this.frontLegPoseCache = frontLegPoseCache;
	//fix scale of exported skin
	sheep.scale.multiplyScalar(0.01);
	sheep.rotation.x = Math.PI * -0.5;
	this.add(sheep);
	sheep.castShadow = true;
	sheep.receiveShadow = true;

	//exports
	this.spineBones = spineBones;
	this.skeleton = skeleton;
	this.rearLeg = rearLeg;
	this.frontLeg = frontLeg;
	this.rearLeg2 = rearLeg2;
	this.frontLeg2 = frontLeg2;

	var helperMaterial = new THREE.MeshBasicMaterial({
		wireframe: true,
		depthTest: false,
		transparent: true
	});
	var bodyHelper = new THREE.Mesh(
		new THREE.SphereGeometry(0.17),
		helperMaterial
	);
	this.add(bodyHelper);
	bodyHelper.visible = this.showHelpers;

	var now = performance.now();
	var nowish = now * 0.01;
	var nowishSlow = nowish * 0.5;
	this.nextPosition.set(
		Math.cos(nowish * 0.05) * 4,
		Math.cos(nowish+Math.PI * -1.5) * 0.1 + 0.7,
		Math.sin(nowish * 0.05) * 4
	);
	this.position.copy(this.nextPosition);

	function createFootTarget(guide, delay) {
		var footTarget = new THREE.Mesh(
			new THREE.SphereGeometry(0.05),
			helperMaterial
		);
		_this.parent.add(footTarget);

		footTarget.position.copy(_this.position);
		footTarget.position.y = 0;
		footTarget.position._virtualY = 0;
		Object.defineProperty(
			footTarget.position, 
			'virtualY', 
			{
				get: function() {
					return this._virtualY;
				},
				set: function(val) {
					this.y = Math.sin(val * Math.PI) * 0.45;
					this._virtualY = val;
				}
			}
		);
		footTarget.lastPosition = footTarget.position.clone();
		_this.stepFoot(footTarget, guide, delay / _this.speed);

		footTarget.visible = _this.showHelpers;
		return footTarget;
	}

	this.footTargetLeft = createFootTarget(this.rearLeg2[0]);
	this.footTargetRight = createFootTarget(this.rearLeg[0], 100);

	this.handTargetLeft = createFootTarget(this.frontLeg2[0], 200);
	this.handTargetRight = createFootTarget(this.frontLeg[0], 300);
}

GoldHornedSheep.prototype = Object.create(THREE.Object3D.prototype);

var __tempVec = new THREE.Vector3();
var __pos = new THREE.Vector3();
var __scale = new THREE.Vector3();
var __rot = new THREE.Euler();
var __quat = new THREE.Quaternion();
var __mat = new THREE.Matrix4();

GoldHornedSheep.prototype.sleepFoot = function(footTarget, guide) {
	tweener.to(
		footTarget.position,
		0.3 / this.speed,
		{
			onComplete: this.stepFoot.bind(this, footTarget, guide)
		}
	)
}

GoldHornedSheep.prototype.stepFoot = function(footTarget, guide, delay) {
	__pos.set(0, 0, 0);
	__pos.applyMatrix4(guide.matrixWorld);
	footTarget.position.virtualY = 0;
	tweener.to(
		footTarget.position,
		0.3 / this.speed,
		{
			// x: __pos.x,
			// y: __pos.y,
			// z: __pos.z,
			x: __pos.x + (__pos.x - footTarget.lastPosition.x) * 1,
			// y: __pos.y,
			z: __pos.z + (__pos.z - footTarget.lastPosition.z) * 1,
			virtualY: 1,
			delay: delay || 0,
			onComplete: this.sleepFoot.bind(this, footTarget, guide)
		}
	)
	footTarget.lastPosition.copy(__pos);
}

function __updateHelperWorldMatrix(leg, helper) {
	leg.updateMatrix();
	leg.parent.updateMatrix();
	leg.updateMatrixWorld();
	leg.parent.updateMatrixWorld();
	helper.position.set(0, 0, 0).applyMatrix4(leg.matrixWorld);
	helper.updateMatrix();
	helper.updateMatrixWorld();
}

GoldHornedSheep.prototype.onEnterFrame = function(dt) {
	var now = performance.now();
	var nowish = now * 0.01 * this.speed;
	var nowishSlow = nowish * 0.5;
	this.nextPosition.set(
		Math.cos(nowish * 0.1 + Math.PI * 0.5) * 2,
		Math.cos(nowish+Math.PI * 0.1 * 0.6) * 0.02 + 0.7,
		// 0.7,
		Math.sin(nowish * 0.05) * 4
	);
	this.lookAt(this.nextPosition);
	this.position.copy(this.nextPosition);
	if(this.skeleton) {
		this.skeleton.rotation.y = Math.sin(nowish * Math.PI * 2 * 0.6 * 0.1 + 1.57) * 0.1 - Math.PI * 0.5;
		// this.skeleton.rotation.z = Math.cos(nowish * Math.PI * 2 * 0.6 * 0.5 + 1.57) * 0.1;
		this.spineBones.forEach(function(bone, i) {
			bone.rotation.z = bone.rotation.originalZ - Math.sin(nowish + i) * 0.1;
			// bone.rotation.x = bone.rotation.originalY - Math.cos(nowish + i) * 0.1;
		});
		this.skull.rotation.x = Math.sin(nowishSlow) * 0.2;
		this.jaw.rotation.z = Math.sin(nowish - 4) * 0.3 - 0.3;
		// var index = ~~nowish % rearLegPoseCache.length;

		__updateHelperWorldMatrix(this.rearLeg[0], this.worldHip);
		__updateHelperWorldMatrix(this.frontLeg[0], this.worldShoulder);
		__updateHelperWorldMatrix(this.rearLeg2[0], this.worldHip2);
		__updateHelperWorldMatrix(this.frontLeg2[0], this.worldShoulder2);

		this.worldFoot.position.copy(this.footTargetRight.position);
		this.worldHand.position.copy(this.handTargetRight.position);
		this.worldFoot2.position.copy(this.footTargetLeft.position);
		this.worldHand2.position.copy(this.handTargetLeft.position);

		var length = 1;
		function prepTempDeltas(result) {
			result.tempDelta = Math.abs(length - result.length);
		}

		function sortByClosestDistance(a, b) {
			return a.tempDelta - b.tempDelta;
		}

		function solveLeg(startBoneHelper, endBoneHelper, poseCache, legArr, flip, flipFix) {
			var direction = flip ? -1 : 1;
			//find the length from the shoulder/hip to the target
			//helpers in world space
			__tempVec.copy(startBoneHelper.position).sub(endBoneHelper.position);
			length = __tempVec.length();
			//sort cache by length delta
			poseCache.forEach(prepTempDeltas);
			poseCache.sort(sortByClosestDistance);

			//point whole leg pose at the target
			__pos.copy(endBoneHelper.position);
			__mat.getInverse(legArr[0].parent.matrixWorld);
			__pos.applyMatrix4(__mat);
			legArr[0].lookAt(__pos);
			legArr[0].rotation.x -= Math.PI * 0.5 * direction;
			
			//set leg to correct pose from cache
			var bestPose = poseCache[0];
			legArr[0].rotation.z -= Math.PI * 0.5 + bestPose.majorAngle * direction;
			legArr[1].rotation.z = bestPose.angle1;
			legArr[2].rotation.z = bestPose.angle2;

		}
		solveLeg(this.worldHip, this.worldFoot, this.rearLegPoseCache, this.rearLeg, false);
		solveLeg(this.worldHip2, this.worldFoot2, this.rearLegPoseCache, this.rearLeg2, true);
		solveLeg(this.worldShoulder, this.worldHand, this.frontLegPoseCache, this.frontLeg, false);
		solveLeg(this.worldShoulder2, this.worldHand2, this.frontLegPoseCache, this.frontLeg2, true);

	}

	// this.rotation.y += 0.01;
}

module.exports = GoldHornedSheep;
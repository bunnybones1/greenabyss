const THREE = require('three');
var defaults = require('lodash.defaults');
var eases = require('eases');

var __defaultParams = {
	segsX: 16,
	segsY: 10,
	radius: 80,
	mapFrameTop: 0,
	mapFrameBottom: 4,
	mapTotalHeight: 256,
	sunToHaloRatio: 0.1,
	phiStart: 0,
	phiLength: Math.PI * 2,
	thetaStart: 0,
	thetaLength: Math.PI * 0.2
};

function SpriteSkyGeometry(params) {
	params = defaults(params, __defaultParams);

	THREE.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';


	params.radius = params.radius || 50;

	params.segsX = Math.max( 3, Math.floor( params.segsX ) || 8 );
	params.segsY = Math.max( 2, Math.floor( params.segsY ) || 6 );

	params.phiStart = params.phiStart !== undefined ? params.phiStart : 0;
	params.phiLength = params.phiLength !== undefined ? params.phiLength : Math.PI * 2;

	params.thetaStart = params.thetaStart !== undefined ? params.thetaStart : 0;
	params.thetaLength = params.thetaLength !== undefined ? params.thetaLength : Math.PI;

	var thetaEnd = params.thetaStart + params.thetaLength;

	var halfPixelOffset = 0.5 / params.mapTotalHeight;
	var mapFrameHeight = params.mapFrameBottom - params.mapFrameTop;
	var adjustedFrameHeight = (mapFrameHeight - 1) / params.mapTotalHeight;
	var topOffset = halfPixelOffset * (1 + 2 * params.mapFrameTop);
	var sunToHaloRatio = params.sunToHaloRatio;


	var ix, iy;

	var index = 0;
	var grid = [];

	var vertex = new THREE.Vector3();
	var normal = new THREE.Vector3();

	// buffers

	var indices = [];
	var vertices = [];
	var normals = [];
	var uvs = [];

	// generate vertices, normals and uvs

	for ( iy = 0; iy <= params.segsY; iy ++ ) {

		var verticesRow = [];

		var v = iy / params.segsY;

		var v2 = eases.quartIn(v);
		if(iy > 0) {
			v2 = sunToHaloRatio + v2 * (1 - sunToHaloRatio);
		}

		for ( ix = 0; ix <= params.segsX; ix ++ ) {

			var u = ix / params.segsX;

			// vertex

			vertex.x = - params.radius * Math.cos( params.phiStart + u * params.phiLength ) * Math.sin( params.thetaStart + v2 * params.thetaLength );
			vertex.y = params.radius * Math.cos( params.thetaStart + v2 * params.thetaLength );
			vertex.z = params.radius * Math.sin( params.phiStart + u * params.phiLength ) * Math.sin( params.thetaStart + v2 * params.thetaLength );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( v, u * adjustedFrameHeight + topOffset );

			verticesRow.push( index ++ );

		}

		grid.push( verticesRow );

	}

	// indices

	for ( iy = 0; iy < params.segsY; iy ++ ) {

		for ( ix = 0; ix < params.segsX; ix ++ ) {

			var a = grid[ iy ][ ix + 1 ];
			var b = grid[ iy ][ ix ];
			var c = grid[ iy + 1 ][ ix ];
			var d = grid[ iy + 1 ][ ix + 1 ];

			if ( iy !== 0 || params.thetaStart > 0 ) indices.push( a, b, d );
			if ( iy !== params.segsY - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );












	// THREE.SphereGeometry.call(this, params.params.radius, params.segsX, params.segsY, undefined, undefined, 0, params.theta);
	// var halfPixelOffset = 0.5 / params.mapTotalHeight;
	// var mapFrameHeight = params.mapFrameBottom - params.mapFrameTop;
	// var adjustedFrameHeight = (mapFrameHeight - 1) / params.mapTotalHeight;
	// var topOffset = halfPixelOffset * (1 + 2 * params.mapFrameTop);
	// var sunToHaloRatio = params.sunToHaloRatio;
	// this.faceVertexUvs[0].forEach(function(faceUvs) {
	// 	faceUvs.forEach(function(uv) {
	// 		var temp = uv.x;
	// 		uv.x = 1 - uv.y;
	// 		uv.y = temp;
	// 		// uv.x = -sunToHaloRatio + uv.x * (1 + sunToHaloRatio),
	// 		// uv.x = eases.quintOut(uv.x);
	// 		uv.y *= adjustedFrameHeight;
	// 		uv.y += topOffset;
	// 	})
	// });
}

SpriteSkyGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

module.exports = SpriteSkyGeometry;
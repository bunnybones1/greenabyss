const colorVertices = require('geometry/utils/colorVertices');

function IconCloseGeometry(params) {
	THREE.Geometry.call(this);

	var headsetRadius = params.size * 0.5;
	var headsetAspect = 0.66;
	var eyePerimeterSegments = 16;
	var eyeRadius = params.size * 0.09;
	var noseRadius = params.size * 0.06;
	var noseOffset = params.size * -0.15;

	function makeCircle(offsetX) {
		var circlePoints = [];
		for (var i = 0; i < eyePerimeterSegments; i++) {
			var ratio = i / eyePerimeterSegments;
			var radians = ratio * Math.PI * 2;
			circlePoints.push(new THREE.Vector2(Math.cos(radians) * eyeRadius + offsetX, Math.sin(radians) * eyeRadius));
		}
		circlePoints.push(circlePoints[0]);
		circlePoints.reverse();
		var shape = new THREE.Shape(circlePoints);
		return shape;
	}

	var buttonOffset = 0.18 * params.size;
	var circleHole = makeCircle(-buttonOffset);
	var circleHole2 = makeCircle(buttonOffset);

	var headsetPoints = [];
	for (var i = 0; i < 4; i++) {
		var angle = Math.PI * 2 * (i+0.5) / 4;
		headsetPoints.push(new THREE.Vector2(Math.cos(angle) * headsetRadius, Math.sin(angle) * headsetRadius * headsetAspect));
	}

	var nosePoints = [];
	for (var i = 0; i <= 5; i++) {
		var angle = Math.PI * (i+0.5) / 5;
		nosePoints.push(new THREE.Vector2(Math.cos(angle) * noseRadius, Math.sin(angle) * noseRadius + noseOffset));
	}
	nosePoints.reverse();
	nosePoints.unshift(new THREE.Vector2(-noseRadius, headsetPoints[2].y));
	nosePoints.push(new THREE.Vector2(noseRadius, headsetPoints[2].y));
	var arguments = [3, 0];
	arguments = arguments.concat(nosePoints);
	headsetPoints.splice.apply(headsetPoints, arguments);

	var shape = new THREE.Shape(headsetPoints);
	shape.holes.push(circleHole);
	shape.holes.push(circleHole2);
	var shapeGeometry = new THREE.ShapeGeometry(shape);
	this.merge(shapeGeometry);
}

IconCloseGeometry.prototype = Object.create(THREE.Geometry.prototype);

module.exports = IconCloseGeometry;